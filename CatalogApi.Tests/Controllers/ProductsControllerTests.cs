using CatalogApi.Common;
using CatalogApi.Controllers;
using CatalogApi.Data.Repositories;
using CatalogApi.Models;
using CatalogApi.Tests.Helpers;
using FluentAssertions;
using FluentValidation;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Http.HttpResults;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using Moq;
using OnlineStoreMVP.ServiceDefaults.Models;
using OnlineStoreMVP.TestUtilities.Helpers;
using System.Threading.Tasks;

namespace CatalogApi.Tests.Controllers;

public class ProductsControllerTests
{
    private readonly Mock<ILogger<ProductsController>> _mockLogger;
    private readonly Mock<IValidator<ProductModel>> _mockValidator;
    private readonly Mock<IProductRepository> _mockRepository;
    private readonly ProductsController _controller;

    public ProductsControllerTests()
    {
        _mockLogger = MockHelpers.CreateMockLogger<ProductsController>();
        _mockValidator = ValidationHelpers.CreateValidValidator<ProductModel>();
        _mockRepository = new Mock<IProductRepository>();
        _controller = new ProductsController(
            _mockLogger.Object,
            _mockRepository.Object,
            _mockValidator.Object);

        // Set up HttpContext for the controller
        SetupHttpContext(_controller);
    }

    /// <summary>
    /// Sets up a mock HttpContext with a TraceIdentifier for the controller.
    /// </summary>
    private static void SetupHttpContext(ControllerBase controller)
        => controller.ControllerContext = new ControllerContext
        {
            HttpContext = new DefaultHttpContext
            {
                TraceIdentifier = Guid.NewGuid().ToString() // Set a trace ID
            }
        };

    public class CreateProductTests : ProductsControllerTests
    {
        /// <summary>
        /// Verifies that creating a product with valid data returns a 201 Created response and the correct product
        /// information.
        /// </summary>
        /// <remarks>This test ensures that the CreateProduct action of the ProductsController returns a
        /// CreatedAtActionResult with status code 201 when provided with a valid product. It also verifies that the
        /// returned product matches the input and that the repository and validator are called as expected.</remarks>
        /// <returns>A completed task representing the asynchronous test execution.</returns>
        [Fact]
        public async Task CreateProduct_WithValidProduct_Returns201Created()
        {
            // Arrange

            // Create a valid product to add
            var productToCreate = ProductTestHelpers.CreateTestProduct();

            // Setup the mock repository to return the created product
            _mockRepository.Setup(r => r.AddAsync(It.IsAny<ProductModel>()))
                           .ReturnsAsync((ProductModel p) => productToCreate); // Return the product that was passed in

            // Act

            // Call the CreateProduct method
            var result = await _controller.CreateProduct(productToCreate);

            // Assert

            // Assert that the result is CreatedAtActionResult
            result.Should()
                  .BeOfType<CreatedAtActionResult>();

            // Further assert on the CreatedAtActionResult
            var createdAtResult = result as CreatedAtActionResult;
            createdAtResult.Should().NotBeNull();
            createdAtResult!.StatusCode.Should().Be(201);
            createdAtResult.ActionName.Should().Be(nameof(ProductsController.GetProduct));

            // Assert that the returned product matches the created product
            createdAtResult.Value.Should().BeOfType<ProductModel>();
            var returnedProduct = createdAtResult.Value as ProductModel;
            returnedProduct.Should().NotBeNull();
            returnedProduct!.Name.Should().Be(productToCreate.Name);
            returnedProduct.Description.Should().Be(productToCreate.Description);
            returnedProduct.Price.Should().Be(productToCreate.Price);
            returnedProduct.Stock.Should().Be(productToCreate.Stock);

            // Verify that a new Guid was generated (ID should not be empty)
            returnedProduct.Id.Should().NotBeEmpty();
            returnedProduct.Id.Should().NotBe(Guid.Empty);

            // Verify repository was called with the product
            _mockRepository.Verify(
                r => r.AddAsync(It.IsAny<ProductModel>()),
                Times.Once);

            // Verify validator was called
            _mockValidator.Verify(
                v => v.Validate(It.Is<ProductModel>(p => p == productToCreate)),
                Times.Once);
        }

        /// <summary>
        /// Verifies that creating a product with an empty identifier results in a new GUID being generated by the
        /// repository.
        /// </summary>
        /// <remarks>This test ensures that when a product is created with an empty <see cref="Guid"/> as
        /// its identifier, the repository assigns a new, non-empty GUID to the product. It also verifies that the
        /// repository and validator are called as expected during the creation process.</remarks>
        /// <returns>A task that represents the asynchronous test operation.</returns>
        [Fact]
        public async Task CreateProduct_WhenIdIsEmpty_GeneratesNewGuid()
        {
            // Arrange
            var productToCreate = ProductTestHelpers.CreateTestProduct(id: Guid.Empty);

            // Mock repository to simulate Guid generation (as the real repository does)
            var generatedId = Guid.NewGuid();
            _mockRepository.Setup(r => r.AddAsync(It.IsAny<ProductModel>()))
                .ReturnsAsync((ProductModel p) =>
                {
                    // Simulate what the real repository does: generate ID and return product
                    p.Id = generatedId;
                    return p;
                });

            // Act
            var result = await _controller.CreateProduct(productToCreate);

            // Assert
            result.Should().BeOfType<CreatedAtActionResult>();

            var createdAtResult = result.Should().BeOfType<CreatedAtActionResult>().Subject;
            createdAtResult.StatusCode.Should().Be(201);

            var createdProduct = createdAtResult.Value.Should().BeOfType<ProductModel>().Subject;

            // Verify that a new Guid was generated by the repository
            createdProduct.Id.Should().NotBeEmpty();
            createdProduct.Id.Should().NotBe(Guid.Empty);
            createdProduct.Id.Should().Be(generatedId); // Verify it matches what repository generated

            // Verify repository was called (which generates the ID)
            _mockRepository.Verify(
                r => r.AddAsync(It.IsAny<ProductModel>()),
                Times.Once);

            // Verify validator was called
            _mockValidator.Verify(
                v => v.Validate(It.IsAny<ProductModel>()),
                Times.Once);
        }

        /// <summary>
        /// Verifies that creating a product with invalid data results in a 400 Bad Request response containing
        /// validation errors.
        /// </summary>
        /// <remarks>This test ensures that when the product model fails validation, the controller
        /// returns a BadRequestObjectResult with detailed error information and does not attempt to add the product to
        /// the repository.</remarks>
        /// <returns>A task that represents the asynchronous test operation.</returns>
        [Fact]
        public async Task CreateProduct_WithInvalidProduct_Returns400BadRequest()
        {
            // Arrange
            // Create an invalid product
            var invalidProduct = ProductTestHelpers.CreateInvalidProduct();

            // Setup the mock validator to return validation errors
            var mockInvalidValidator = ValidationHelpers.CreateInvalidValidator<ProductModel>(new Dictionary<string, string[]>
            {
                { nameof(ProductModel.Name), new string[] { Constants.ProductNameRequired } },
                { nameof(ProductModel.Description), new[] { Constants.ProductDescriptionRequired } },
                { nameof(ProductModel.Stock), new[] { Constants.ProductStockMustBeNonNegative } },
                { nameof(ProductModel.Price), new[] { Constants.ProductPriceMustBeGreaterThanZero } }
            });

            // Create controller with the invalid validator
            var controller = new ProductsController(
                _mockLogger.Object,
                _mockRepository.Object,
                mockInvalidValidator.Object); // Use the invalid validator here!

            SetupHttpContext(controller);

            // Act
            // Call the CreateProduct method
            var result = await controller.CreateProduct(invalidProduct);

            // Assert

            // Assert that the result is BadRequestObjectResult
            result.Should().BeOfType<BadRequestObjectResult>();

            var badRequestResult = result.Should().BeOfType<BadRequestObjectResult>().Subject;
            badRequestResult.StatusCode.Should().Be(400);

            // Assert that the returned value contains validation errors
            badRequestResult.Value.Should().BeOfType<ErrorResponse>();
            var errorResponse = badRequestResult.Value.Should().BeOfType<ErrorResponse>().Subject;
            errorResponse.Errors.Should().NotBeNull();

            // Verify validation errors are present
            errorResponse.Errors.Should().ContainKey(nameof(ProductModel.Name));
            errorResponse.Errors[nameof(ProductModel.Name)].Should().Contain(Constants.ProductNameRequired);

            errorResponse.Errors.Should().ContainKey(nameof(ProductModel.Description));
            errorResponse.Errors[nameof(ProductModel.Description)].Should().Contain(Constants.ProductDescriptionRequired);

            errorResponse.Errors.Should().ContainKey(nameof(ProductModel.Stock));
            errorResponse.Errors[nameof(ProductModel.Stock)].Should().Contain(Constants.ProductStockMustBeNonNegative);

            errorResponse.Errors.Should().ContainKey(nameof(ProductModel.Price));
            errorResponse.Errors[nameof(ProductModel.Price)].Should().Contain(Constants.ProductPriceMustBeGreaterThanZero);

            // Verify repository.AddAsync was never called
            _mockRepository.Verify(
                r => r.AddAsync(It.IsAny<ProductModel>()),
                Times.Never);

            // Verify validator was called
            mockInvalidValidator.Verify(
                v => v.Validate(It.Is<ProductModel>(p => p == invalidProduct)),
                Times.Once);
        }
    }

    public class UpdateProductTests
    {
        /*
            - ✅ Returns 204 NoContent when update succeeds
            - ✅ Returns 404 NotFound when product doesn't exist (repository returns null)
            - ✅ Returns 400 BadRequest with validation errors
            - ✅ Verifies repository.UpdateAsync is called with correct parameters
            - ✅ Handles exceptions correctly
        */


    }

    public class GetProductsTests
    {
        /*
            - ✅ Returns 200 OK with list of products
            - ✅ Returns empty list when no products exist
            - ✅ Handles exceptions correctly
        */
    }


    public class GetProductByIdTests
    {
        /*
            - ✅ Returns 200 OK with product when found
            - ✅ Returns 404 NotFound when product doesn't exist (repository returns null)
            - ✅ Handles exceptions correctly
        */

    }

    public class DeleteProductTests
    {
        /*
            - ✅ Returns 204 NoContent when deletion succeeds
            - ✅ Returns 404 NotFound when product doesn't exist (repository returns false)
            - ✅ Handles exceptions correctly 
         */
    }
}
